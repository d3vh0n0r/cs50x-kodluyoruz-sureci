Videolu Ders Notları:
- Soyutlama üzerinde biraz daha durduk. Şöyle ki; yolda yürürken elimizde su şişesi olduğunu varsayalım. Arkadaşımıız suyunu iç dediğinde, suyumuzu içeriz. Fakat bu konularda varsayım yaparız yoksa hayatımız da ki herşey daha kompleks olurdu. Yani aslında suyu direk içmek: şişeyi yukarı kaldır, kapağını çevir, kapağını aç, şişeyi ağzına götür, yukarı dikleyerek sıvı akışını sağla. Aslında su içerken yaptığımız olaylar bunlardır fakat "su iç" diyerek bunları varsayım haline getiririz. Programlama da ise bu varsayımları biraz daha belirtmemiz gerekir. Sayıyı topla diyerek bir program yazamayız değil mi? "int türünde bir sayı kaydet(belleğe) ve diğer int türünden kaydedilmiş sayı ile cebirsel işlem yap" diyerek programımızı yazarız.
- if, else, else if yapılarının basit kullanımı, printf(burdaki f, formatlanmış(resetlenmiş olan anlamı DEĞİL) bir değeri yazdır)'in kullanımını, ; ifadesinin kodlamada(C'de) nokta olarak kullanıldığını, \n kaçış ifadesini gördük, while ile (true) yazarak sonsuz döngüyü gördük. Yani sonsuz döngü için 50 = 50 gibi kafadan uydurma hep gerçekleşen bir ifade yerine boolean değerlerinin önemini anladım.
- get_string("What's your name?\n); diyerek kullanıcıdan bir değer alabiliriz. C'de kelimeler arasında(fonksiyonlarda) boşluk bırakamayız bu yüzden boşluğu  temsil eden '_' karakterini kullanırız.
- String bir karakter dizisidir. Yani string isim = onur aslında isim[4] = [0]=>"o",  [1]=>"n",  [2]=>"u",  [3]=>"r";  sistemselindedir.
- printf("%s", answer); answer'ı %s(ayrıca yer tutucu işlevi görür) yani string olarak formatlanmış şekilde yazdır. printf'in yani formatlanmış bir değeri yazdırmanın pratiğini işledik.
- Günümüzde neden terminal kullanalım GUI(kullanıcı arayüzü) varken sorusunun cevabını öğrendik; çünkü GUI'ler de koddan yazılan programlar olduğu için yazan kişi tarafından imkanlar sınırlandırılır ama terminalde direkt olarak bilgisayara kodlar göndererek istediğimiz şeyi daha imkanlı, açık bir şekilde elde edebiliriz.(bunun ucu 010101leri bizzat yazmaya kadar gider valla.)
- Komut satırı argümanları, varsayılanın dışnıda nasıl davranacağını söylemenin şeklidir. Mesela gcc hello.c varsıylansa, gcc -o(outputu ifade eder) hello hello.c komut satırı argümanlı bir terminal kodudur.
- Fonksiyonlar girdi alarak çalışabilirler ve bu girdiler argüman veya parametre olarak adlandırılır.
- Girdi ve çıktının ne anlama geldiğini ve çıktının üzerinde kod vasıtasıyla durduk. Girdi, mesela name değişkeninin printf'e girilmesi veya printf'e "merhaba" ifadesinin girilmesi girdidir. Çıktı ise get_string fonksiyonuna verdiğimi soru ile kullanıcıdan alınan veridir. Öyleyse printf çıktı verir mi? Hayır(şimdilik). Çünkü printf sadece baskı işlemi yapıyor ama bize(yazılımcıya) herhangi bir çıktı vermiyor.
- conditions(koşullar demek)
- bildiğimiz üzere float türünden bir değeri ele aldığımızda bu değer bellekte bir adres tutar. Float için bu 32 bit yani 4 bytedır. biz printf("%.50f", floatSayi) gibi bir kod yazdığımızda virgülden sonra 50 basamak hassasiyetin de sayımızı yazdıracaktır fakat floatSayi'yi 2 düşünürsek 2.0000...50 adet sıfır yazdırması gerekirken 7.sıfırdan sonra farklı değerler yazdırır. Peki bunun nedeni nedir? Bunun nedeni float floatSayi değişkenimiz bellekte 4 byte yer kaplar ve biz %.50f yaptığımız da ise istediğimiz hassasiyet daha fazla byte a ihtiyac duyar(bu hassasiyeti sağlamak için). Daha fazla byte verilerin compile yani 0-1lere dönüştürüldükten sonra işlemciyi daha çok yormak(bildiğimiz üzere kodlar eninde sonunda 0-1lere dönüşür işlemcinin 100 tane 0-1 ile 1000 tane 0-1 okuması arasinda tabi ki performans farkı olacaktır) ve bellekte daha çok yer tutmak demektir ama aynı zamanda daha hassas sayılar elde etmemize yarar. Bu yüzden 64 bitlik yani 8 bytlık double veri tipini kullanabiliriz.  
- tek bir harf ile koşul yapmak istediğimizde string yerine char kullanmamız daha doğru olur çünkü char tek karakter tutabilir ve stringe göre bellekte tuttuğu veri alanı daha azdır(byte durumu yine). 
- void'in ne olduğunu, nerede kullanıldığını öğrendik. Kendi fonkisoynumuzu yazarkan void(fonksiyonumuz herhangi bir çıktı vermicek demek oluyor) selam(void[yani fonksiyonumuz herhangi bir parametre(girdi), argüman almicak diyoruz]); tamamı aşağıda
- void selam(void) printf("merhaba"); aslında bu kod da soyutlamamıza bir örnek olabilir. biz gidip printf("selam"); yazmak yerine selam(); yazarak aynı işlemi varsayımlarla(ki bunları biz fonksiyonumuzu tanımlarken belirttik) birlikte daha da hızlı yazdirabiliriz.
- Eğer bir kodu birden çok kez tekrar etmeye başladıysak, yanlış yapıyoruz demektir. Çünkü ileride o kodu değiştrimek veya kodu  tercüme(en basitinden) etmek istersek birden çok kez bu işlemleri yapmak durumunda kalıcaz(birbiriyle tıpatıp aynı kodlar için bahsediyorum).
- Kod bloklarımızın üsten aşağı ve sağdan sola doğru okunduğunu öğrendik. Bu yüzden fonksiyonlarımızı oluştururken source'ımızın olabildiğince üst taraflarında oluşturmaya dikkat etmeliyiz.
- Evet üstteki tezi çürüttük hehe. Prototip fonksiyonu öğrendim. programın üst tarafında fonksiyonu veri tipi ve girdileriyle birlikte tanımlarsak artık fonksiyonumuzun detaylarını istediğimiz yere yazabiliyoruz.
- return ile fonksiyonlara değer döndürülmesi ve scope kavramına değindik. Scope, iki süslü parantezin arasında değişkenin(veya başka bir ifadenin) belirtildiği yerdir.
- do-while döngüsünü gördük. En büyük özelliğinin EN AZ 1 kere çalışması olduğunu öğrendik.
- Overflow kavramına değindik. Mesela 3 hane tutabilen bir Kronometremiz var. 999 saniyeye +1 saniye daha eklersek 9 9 9 10 olmaz. 9 evrilir ve elde dediğimiz durum haline gelerek soldaki basamağa gider ve böyle böyle elde kalmayana kadar işlem devam eder ve haliyle 1000 olur ama kronometremiz en fazla 3 hane tutabildiği için 000 gösterecektir. Bu olaya overflow yani taşma adı verilir. Bunu 2lik sayı sisteminde örnek verirsek 111'e 1 eklersek sırasıyla 110 > 100 > (elde var 1 yine) 000 > 1000 4 bitlik bir değer elde ederiz. int'in 32 bit olduğunu daha öncesinde değinmiştik. Peki kendi kendini toplayan bir döngü oluştursak ve değerimizi int içinde tutarsak 32 bitlik bir sayı oluştuktan sonra 33.biti oluşturmaya çalışırken overflow olacak ve bize hata verecektir.
